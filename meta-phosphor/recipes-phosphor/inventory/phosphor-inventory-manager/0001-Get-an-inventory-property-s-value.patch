From 10c1a87e95a728c56a15d8dad9a9a3092a82eebb Mon Sep 17 00:00:00 2001
From: Matthew Barth <msbarth@us.ibm.com>
Date: Wed, 26 Sep 2018 15:06:15 -0500
Subject: [PATCH 1/1] Get an inventory property's value

Adds support for inventory manager to retrieve a property's value that
it hosts as input to condition tests. Utilizing a provided sdbusplus
server binding member function to get a property from the inventory
hosted interface, a property can be read from that interface within
inventory manager. After the property is read, the condition test is
performed and the resulting action(s) occur.

The only currently supported condition test for using a property from
within inventory manager is the `propertyIs` condition.

This is an example of the expected generated source to get a property
from within inventory manager:

make_filter(functor::propertyIs(
    "/system/chassis",
    "xyz.openbmc_project.Inventory.Decorator.CoolingType",
    "WaterCooled",
    true,
    "xyz.openbmc_project.Inventory.Manager",
    make_get_property<sdbusplus::xyz::openbmc_project::Inventory::
                      Decorator::server::CoolingType::PropertiesVariant>
    (
        functor::getProperty<sdbusplus::xyz::openbmc_project::
            Inventory::Decorator::server::CoolingType>
        (
                "/system/chassis",
                "xyz.openbmc_project.Inventory.Decorator.CoolingType",
                &sdbusplus::xyz::openbmc_project::Inventory::
                    Decorator::server::CoolingType::getPropertyByName,
                "WaterCooled"
        )
    )
))

Tested:
    Manually edited generated code to use property within inventory
    and actions occurred when condition passed
    Manually edited generated code to use property within inventory
    and actions did not run when condition failed
    Actions not run when get property function omitted

Change-Id: I094bbacbcdeb239d33cac343b2daeb5f86e0a58a
Signed-off-by: Matthew Barth <msbarth@us.ibm.com>
---
 functor.cpp |  21 +++++++++++--
 functor.hpp | 103 +++++++++++++++++++++++++++++++++++++++++++++++++-----------
 types.hpp   |   1 +
 3 files changed, 104 insertions(+), 21 deletions(-)

diff --git a/functor.cpp b/functor.cpp
index b9e2521..0c0f8e9 100644
--- a/functor.cpp
+++ b/functor.cpp
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 #include "functor.hpp"
+#include "config.h"
+#include "manager.hpp"
 #include <sdbusplus/bus.hpp>
 
 namespace phosphor
@@ -33,7 +35,8 @@ bool PropertyConditionBase::operator()(sdbusplus::bus::bus& bus,
 }
 
 bool PropertyConditionBase::operator()(const std::string& path,
-                                       sdbusplus::bus::bus& bus, Manager&) const
+                                       sdbusplus::bus::bus& bus,
+                                       Manager& mgr) const
 {
     std::string host;
 
@@ -65,13 +68,25 @@ bool PropertyConditionBase::operator()(const std::string& path,
         }
 
         host = mapperResponse.begin()->first;
+    }
 
-        if (host == bus.get_unique_name())
+    // When the host service name is inventory manager, eval using
+    // a given `getProperty` function to retrieve a property value from
+    // an interface hosted by inventory manager.
+    if (host == BUSNAME)
+    {
+        try
         {
-            // TODO I can't call myself here.
+            return eval(mgr);
+        }
+        catch (const std::exception& e)
+        {
+            // Unable to find property on inventory manager,
+            // default condition to false.
             return false;
         }
     }
+
     auto hostCall = bus.new_method_call(
         host.c_str(), path.c_str(), "org.freedesktop.DBus.Properties", "Get");
     hostCall.append(_iface);
diff --git a/functor.hpp b/functor.hpp
index fc763e5..e183016 100644
--- a/functor.hpp
+++ b/functor.hpp
@@ -57,6 +57,21 @@ template <typename T> auto make_path_condition(T&& condition)
     return PathCondition(std::forward<T>(condition));
 }
 
+/** @brief make_get_property
+ *
+ *  Adapt a get_property function object.
+ *
+ *  @param[in] method - The functor being adapted.
+ *  @returns - The adapted functor.
+ *
+ *  @tparam T - The return type of the function object.
+ *  @tparam U - The type of the functor being adapted.
+ */
+template <typename T, typename U> auto make_get_property(U&& method)
+{
+    return GetProperty<T>(std::forward<U>(method));
+}
+
 template <typename T, typename... Args>
 auto callArrayWithStatus(T&& container, Args&&... args)
 {
@@ -123,11 +138,8 @@ auto setProperty(std::vector<const char*>&& paths,
     // Bind the path, interface, interface member function pointer,
     // and value to a lambda.  When it is called, forward the
     // path, interface and value on to the manager member function.
-    return [
-        paths, conditions = conditions, iface, member,
-        value = std::forward<V>(value)
-    ](auto& b, auto& m)
-    {
+    return [paths, conditions = conditions, iface, member,
+            value = std::forward<V>(value)](auto& b, auto& m) {
         for (auto p : paths)
         {
             if (callArrayWithStatus(conditions, p, b, m))
@@ -138,6 +150,31 @@ auto setProperty(std::vector<const char*>&& paths,
     };
 }
 
+/** @brief Get a property.
+ *
+ *  Invoke the requested method with a reference to the requested
+ *  sdbusplus server binding interface as a parameter.
+ *
+ *  @tparam T - The sdbusplus server binding interface type.
+ *  @tparam U - The type of the sdbusplus server binding member
+ *      function that sets the property.
+ *
+ *  @param[in] path - The DBus path to get the property from.
+ *  @param[in] iface - The DBus interface hosting the property.
+ *  @param[in] member - Pointer to sdbusplus server binding member.
+ *  @param[in] prop - The property name to get the value from.
+ *
+ *  @returns - A function object that gets the requested property.
+ */
+template <typename T, typename U>
+inline auto getProperty(const char* path, const char* iface, U&& member,
+                        const char* prop)
+{
+    return [path, iface, member, prop](auto& mgr) {
+        return mgr.template invokeMethod<T>(path, iface, member, prop);
+    };
+}
+
 /** @struct PropertyChangedCondition
  *  @brief Match filter functor that tests a property value.
  *
@@ -232,6 +269,9 @@ struct PropertyConditionBase
     /** @brief Forward comparison to type specific implementation. */
     virtual bool eval(sdbusplus::message::message&) const = 0;
 
+    /** @brief Forward comparison to type specific implementation. */
+    virtual bool eval(Manager&) const = 0;
+
     /** @brief Test a property value.
      *
      * Make a DBus call and test the value of any property.
@@ -257,8 +297,9 @@ struct PropertyConditionBase
  *
  *  @tparam T - The type of the property being tested.
  *  @tparam U - The type of the condition checking functor.
+ *  @tparam V - The getProperty functor return type.
  */
-template <typename T, typename U>
+template <typename T, typename U, typename V>
 struct PropertyCondition final : public PropertyConditionBase
 {
     PropertyCondition() = delete;
@@ -270,10 +311,14 @@ struct PropertyCondition final : public PropertyConditionBase
 
     /** @brief Constructor
      *
-     *  The service argument can be nullptr.  If something
-     *  else is provided the function will call the the
+     *  The service & getProperty arguments can be nullptrs.
+     *  If something else is provided the function will call the the
      *  service directly.  If omitted, the function will
      *  look up the service in the ObjectMapper.
+     *  The getProperty function will be called to retrieve a property
+     *  value when given and the property is hosted by inventory manager.
+     *  When not given, the condition will default to return that the
+     *  condition failed and will not be executed.
      *
      *  @param path - The path of the object containing
      *     the property to be tested.
@@ -282,11 +327,15 @@ struct PropertyCondition final : public PropertyConditionBase
      *  @param property - The property to be tested.
      *  @param condition - The test to run on the property.
      *  @param service - The DBus service hosting the object.
+     *  @param getProperty - The function to get a property value
+     *     for the condition.
      */
     PropertyCondition(const char* path, const char* iface, const char* property,
-                      U&& condition, const char* service) :
+                      U&& condition, const char* service,
+                      GetProperty<V>&& getProperty = nullptr) :
         PropertyConditionBase(path, iface, property, service),
-        _condition(std::forward<decltype(condition)>(condition))
+        _condition(std::forward<decltype(condition)>(condition)),
+        _getProperty(getProperty)
     {
     }
 
@@ -301,16 +350,33 @@ struct PropertyCondition final : public PropertyConditionBase
         return _condition(std::forward<T>(value.template get<T>()));
     }
 
+    /** @brief Retrieve a property value from inventory and test it.
+     *
+     *  Get a property from the inventory manager and test the value.
+     *  Default to fail the test where no function is given to get the
+     *  property from the inventory manager.
+     */
+    bool eval(Manager& mgr) const override
+    {
+        if (_getProperty)
+        {
+            auto variant = _getProperty(mgr);
+            auto value = sdbusplus::message::variant_ns::get<T>(variant);
+            return _condition(std::forward<T>(value));
+        }
+        return false;
+    }
+
   private:
     U _condition;
+    GetProperty<V> _getProperty;
 };
 
 /** @brief Implicit type deduction for constructing PropertyChangedCondition. */
 template <typename T>
 auto propertyChangedTo(const char* iface, const char* property, T&& val)
 {
-    auto condition = [val = std::forward<T>(val)](T && arg)
-    {
+    auto condition = [val = std::forward<T>(val)](T&& arg) {
         return arg == val;
     };
     using U = decltype(condition);
@@ -319,17 +385,18 @@ auto propertyChangedTo(const char* iface, const char* property, T&& val)
 }
 
 /** @brief Implicit type deduction for constructing PropertyCondition.  */
-template <typename T>
+template <typename T, typename V = InterfaceVariantType>
 auto propertyIs(const char* path, const char* iface, const char* property,
-                T&& val, const char* service = nullptr)
+                T&& val, const char* service = nullptr,
+                GetProperty<V>&& getProperty = nullptr)
 {
-    auto condition = [val = std::forward<T>(val)](T && arg)
-    {
+    auto condition = [val = std::forward<T>(val)](T&& arg) {
         return arg == val;
     };
     using U = decltype(condition);
-    return PropertyCondition<T, U>(path, iface, property, std::move(condition),
-                                   service);
+    return PropertyCondition<T, U, V>(path, iface, property,
+                                      std::move(condition), service,
+                                      std::move(getProperty));
 }
 } // namespace functor
 } // namespace manager
diff --git a/types.hpp b/types.hpp
index 5b65d5a..587e444 100644
--- a/types.hpp
+++ b/types.hpp
@@ -33,6 +33,7 @@ using Filter = std::function<bool(sdbusplus::bus::bus&,
                                   sdbusplus::message::message&, Manager&)>;
 using PathCondition =
     std::function<bool(const std::string&, sdbusplus::bus::bus&, Manager&)>;
+template <typename T> using GetProperty = std::function<T(Manager&)>;
 } // namespace manager
 } // namespace inventory
 } // namespace phosphor
-- 
1.8.3.1

